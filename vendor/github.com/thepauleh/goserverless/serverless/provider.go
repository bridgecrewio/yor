package serverless

import (
	"encoding/json"
	"fmt"
)

// Provider definition
type Provider struct {
	Name               string                   `json:"name,omitempty"`
	Runtime            string                   `json:"runtime,omitempty"`
	Stage              string                   `json:"stage,omitempty"`
	Region             string                   `json:"region,omitempty"`
	Profile            string                   `json:"profile,omitempty"`
	MemorySize         int                      `json:"memorySize,omitempty"`
	Timeout            int                      `json:"timeout,omitempty"`
	LogRetentionInDays int                      `json:"logRetentionInDays,omitempty"`
	DeploymentBucket   *DeploymentBucket        `json:"deploymentBucket,omitempty"`
	Role               string                   `json:"role,omitempty"`
	CFNRole            string                   `json:"cfnRole,omitempty"`
	VersionFunctions   bool                     `json:"versionFunctions,omitempty"`
	Environment        map[string]interface{}   `json:"environment,omitempty"`
	EndpointType       string                   `json:"endpointType,omitempty"`
	ResourcePolicy     []map[string]interface{} `json:"resourcePolicy,omitempty"`
	StackTags          map[string]interface{}   `json:"stackTags,omitempty"`
	Tracing            *Tracing                 `json:"tracing,omitempty"`
	APIKeys            []string                 `json:"apiKeys,omitempty"`
	IAMRoleStatements  []map[string]interface{} `json:"iamRoleStatements,omitempty"`
	StackPolicy        []map[string]interface{} `json:"stackPolicy,omitempty"`
	NotificationARNs   []string                 `json:"notificationArns,omitempty"`
	VPC                VPC                      `json:"vpc,omitempty"`
}

// DeploymentBucket Deployment bucket name. Default is generated by the framework
type DeploymentBucket struct {
	Name                 string `json:"name,omitempty"`
	ServerSideEncryption string `json:"serverSideEncryption,omitempty"`
	blockPublicAccess    bool   `json:"blockPublicAccess,omitempty"`
}

type Tracing struct {
	Lambda     bool `json:"lambda,omitempty"`
	ApiGateway bool `json:"apiGateway,omitempty"`
}

func (t *Tracing) UnmarshalJSON(bytes []byte) error {
	var tracing interface{}
	if err := json.Unmarshal(bytes, &tracing); err != nil {
		return err
	}
	switch tracing.(type) {
	case bool:
		t.ApiGateway = tracing.(bool)
	case map[string]interface{}:
		if val, ok := tracing.(map[string]interface{})["lambda"]; ok {
			t.Lambda = val.(bool)
		} else if val, ok := tracing.(map[string]interface{})["apiGateway"]; ok {
			t.ApiGateway = val.(bool)
		}
	default:
		return fmt.Errorf("unable to parse provider.tracing")
	}
	return nil
}

func (d *DeploymentBucket) UnmarshalJSON(bytes []byte) error {
	var db interface{}
	if err := json.Unmarshal(bytes, &db); err != nil {
		return err
	}
	switch db.(type) {
	case string:
		d.Name = db.(string)
	case map[string]interface{}:
		if val, ok := db.(map[string]interface{})["name"]; ok {
			d.Name = val.(string)
		}
		if val, ok := db.(map[string]interface{})["serverSideEncryption"]; ok {
			d.ServerSideEncryption = val.(string)
		}
		if val, ok := db.(map[string]interface{})["blockPublicAccess"]; ok {
			d.blockPublicAccess = val.(bool)
		}
	default:
		return fmt.Errorf("unable to parse provider.tracing")
	}
	return nil
}
